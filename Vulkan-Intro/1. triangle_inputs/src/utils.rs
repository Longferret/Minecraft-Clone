use std::sync::Arc;
use vulkano::buffer::{BufferContents, Subbuffer};
use vulkano::command_buffer::allocator::StandardCommandBufferAllocator;
use vulkano::command_buffer::{
    AutoCommandBufferBuilder, CommandBufferUsage, PrimaryAutoCommandBuffer, RenderPassBeginInfo,
    SubpassBeginInfo, SubpassContents,
};
use vulkano::device::physical::{PhysicalDevice, PhysicalDeviceType};
use vulkano::device::{
    Device, DeviceExtensions, Queue, QueueFlags,
};
use vulkano::image::view::ImageView;
use vulkano::image::Image;
use vulkano::instance::Instance;
use vulkano::pipeline::graphics::color_blend::{ColorBlendAttachmentState, ColorBlendState};
use vulkano::pipeline::graphics::input_assembly::InputAssemblyState;
use vulkano::pipeline::graphics::multisample::MultisampleState;
use vulkano::pipeline::graphics::rasterization::RasterizationState;
use vulkano::pipeline::graphics::vertex_input::{Vertex, VertexDefinition};
use vulkano::pipeline::graphics::viewport::{Viewport, ViewportState};
use vulkano::pipeline::graphics::GraphicsPipelineCreateInfo;
use vulkano::pipeline::layout::PipelineDescriptorSetLayoutCreateInfo;
use vulkano::pipeline::{GraphicsPipeline, PipelineLayout, PipelineShaderStageCreateInfo};
use vulkano::render_pass::{Framebuffer, FramebufferCreateInfo, RenderPass, Subpass};
use vulkano::shader::ShaderModule;
use vulkano::swapchain::{Surface, Swapchain};



// Structure that store a vertex to be used for drawing.
#[derive(BufferContents, Vertex,Debug,Clone,Copy)]  // Used to be able to pass to data through a buffer to the GPU
#[repr(C)]                                          // For Vulkan, data is stored as in the C language
pub struct MyVertex {
    #[format(R32G32_SFLOAT)]    // Need to specify for Vulkan
    pub position: [f32; 2],     // Actual data
}

// These modules are the shaders, a shader is a program that run on the GPU.
// the vertex shader will make transformation on the vertices
// the fragment shader will make transformation on the triangles generated by the vertex shader
pub mod vs {
    // macro of vulkano to define a shader
    vulkano_shaders::shader! {
        ty: "vertex",   // type of shader 
        // GLSL code of the shader
        src: r"
            #version 460

            layout(location = 0) in vec2 position;

            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        ",
    }
}
pub mod fs {
    vulkano_shaders::shader! {
        ty: "fragment",
        src: r"
            #version 460

            layout(location = 0) out vec4 f_color;

            void main() {
                f_color = vec4(0.0, 1.0, 1.0, 1);
            }
        ",
    }
}

pub fn get_command_buffers(
    command_buffer_allocator: &StandardCommandBufferAllocator,
    queue: &Arc<Queue>,
    pipeline: &Arc<GraphicsPipeline>,
    framebuffers: &[Arc<Framebuffer>],
    vertex_buffer: &Vec<Subbuffer<[MyVertex]>>,) -> Vec<Arc<PrimaryAutoCommandBuffer>> {
    
    let mut out_buffers = Vec::new();
    let mut index = 0;
    // Loop over the framebuffers
    for framebuffer in framebuffers{
        // Create a builder, the first step to create the command buffer
        let mut builder = AutoCommandBufferBuilder::primary(
            command_buffer_allocator,
            queue.queue_family_index(),            
            CommandBufferUsage::MultipleSubmit,  // this command buffer will be used for multiple submit
        )
        .unwrap();

        // From the builder we can call multiple functions to make out command buffer
        builder
            // Starting a render pass using a framebuffer and providing the clear_values
            .begin_render_pass(
                RenderPassBeginInfo {
                    clear_values: vec![Some([0.0, 0.68, 1.0, 1.0].into())],
                    ..RenderPassBeginInfo::framebuffer(framebuffer.clone())
                },
                SubpassBeginInfo {
                    contents: SubpassContents::Inline,
                    ..Default::default()
                },
            )
            .unwrap()
            // Binds the pipeline (the graphical operation to execute: vertex shader,fragment shader, ..)
            .bind_pipeline_graphics(pipeline.clone())
            .unwrap()
            // Binds the vertex buffer 
            .bind_vertex_buffers(0, vertex_buffer[index].clone())
            .unwrap()
            // Start the operation
            .draw(vertex_buffer[index].len() as u32, 1, 0, 0)
            .unwrap()
            // End the renderpass
            .end_render_pass(Default::default())
            .unwrap();

        out_buffers.push(builder.build().unwrap());
        index += 1;
    }
    out_buffers
}

pub fn select_physical_device(
    instance: &Arc<Instance>,
    surface: &Arc<Surface>,
    device_extensions: &DeviceExtensions,) -> (Arc<PhysicalDevice>, u32) {
        
    instance
        .enumerate_physical_devices() // Get all available physical devices
        .expect("failed to enumerate physical devices")
        .filter(|p| p.supported_extensions().contains(device_extensions)) // Only keep those that have the specified extensions
        // Only keep queue family that have "GRAPHICS" flag and can draw on a Surface.
        // Return them as (physical device, index_queue_family)
        .filter_map(|p| { 
            p.queue_family_properties()
                .iter()
                .enumerate()
                .position(|(i, q)| {
                    q.queue_flags.contains(QueueFlags::GRAPHICS)
                        && p.surface_support(i as u32, surface).unwrap_or(false)
                })
                .map(|q| (p, q as u32))
        })
        // Sort the (physical device, index_queue_family) by Physical device type
        // Return the first (physical device, index_queue_family) --> the best device to use
        .min_by_key(|(p, _)| match p.properties().device_type {
            PhysicalDeviceType::DiscreteGpu => 0,
            PhysicalDeviceType::IntegratedGpu => 1,
            PhysicalDeviceType::VirtualGpu => 2,
            PhysicalDeviceType::Cpu => 3,
            _ => 4,
        })
        .expect("no device available")
}

pub fn get_render_pass(device: Arc<Device>, swapchain: Arc<Swapchain>) -> Arc<RenderPass> {
    // This macro is used to create a renderpass with 1 subpass (simple case).
    vulkano::single_pass_renderpass!(
        device,  // the logical GPU
        attachments: {  // list of attachments
            color: {                                // name of the attachment (can be anything)
                format: swapchain.image_format(),   // set the format the same as the swapchain
                samples: 1,                         // 1 sample per pixel can bet set to more for multisampling (for antialiasing)                       
                load_op: Clear,                     // what happens at start of render pass, Clear =  we set all img pixel to a value
                store_op: Store,                    // what happens at end of render pass, here we store the values
            },
        },
        pass: {         // list of subpasses
            color: [color],                         // uses color attachment as color
            depth_stencil: {},                      // does not use any depth or stencil attachment
        },
    )
    .unwrap()
}

pub fn get_framebuffers(images: &[Arc<Image>], render_pass: Arc<RenderPass>) -> Vec<Arc<Framebuffer>> {
    // For all images, create a framebuffer tied to the render pass
    images
        .iter()
        .map(|image| { 
            // Define an imageView, it is just a descriptive object that tells the GPU how to acces the actual image
            let view = ImageView::new_default(image.clone()).unwrap();
            // Define the frame buffer
            Framebuffer::new(
                render_pass.clone(),                    // the render pass that we want to be tied to
                FramebufferCreateInfo {    
                    attachments: vec![view],            // attachment for the renderpass
                    ..Default::default()                // rest to default
                },
            )
            .unwrap()
        })
        .collect::<Vec<_>>()
}

pub fn get_pipeline(
    device: Arc<Device>,
    vs: Arc<ShaderModule>,
    fs: Arc<ShaderModule>,
    render_pass: Arc<RenderPass>,
    viewport: Viewport,) -> Arc<GraphicsPipeline> {
    // Retreive shaders entry points
    let vs = vs.entry_point("main").unwrap();
    let fs = fs.entry_point("main").unwrap();
    
    let vertex_input_state = MyVertex::per_vertex()
        .definition(&vs.info().input_interface)
        .unwrap();

    let stages = [
        PipelineShaderStageCreateInfo::new(vs),
        PipelineShaderStageCreateInfo::new(fs),
    ];

    let layout = PipelineLayout::new(
        device.clone(),
        PipelineDescriptorSetLayoutCreateInfo::from_stages(&stages)
            .into_pipeline_layout_create_info(device.clone())
            .unwrap(),
    )
    .unwrap();

    let subpass = Subpass::from(render_pass.clone(), 0).unwrap();

    GraphicsPipeline::new(
        device.clone(),   
        None,
        GraphicsPipelineCreateInfo {
            stages: stages.into_iter().collect(),                           // definition of the shader stages (2 here, verte + fragement)
            vertex_input_state: Some(vertex_input_state),                   // definition of the vertex inputs (use 1 of our vertex structure on a vertex shader)
            input_assembly_state: Some(InputAssemblyState::default()),      // vertex data is assembled into triangles
            viewport_state: Some(ViewportState {                            // our viewport
                viewports: [viewport].into_iter().collect(),
                ..Default::default()
            }),
            rasterization_state: Some(RasterizationState::default()),       // option on rasterization state (fragments)  
            multisample_state: Some(MultisampleState::default()),           // default, we don't use multisampling
            color_blend_state: Some(ColorBlendState::with_attachment_states(// Describes how the color output of the fragment shader is written to the attachment
                subpass.num_color_attachments(),
                ColorBlendAttachmentState::default(),
            )),
            subpass: Some(subpass.into()),                                  // the subpass to use 
            ..GraphicsPipelineCreateInfo::layout(layout)
        },
    )
    .unwrap()
}











